#' Export wordlist
#'
#' \code{ar_wordlist_export()} exports a table of responses for manual spelling correction.
#'
#' @param associations an \code{associatoR} object containing association data as generated by \link[associatoR]{ar_import}.
#' @param file a \code{character} string specifying the filename including folders. Default is \code{"wordlist_correction.csv"}.
#' @param check_spelling a \code{logical} specifying whether to include a column identifying likely mispelled words based on the \link[spelling]{spell_check_text}. Note that currently the spell check only works for English associations. Default is \code{TRUE}.
#' @param check_acronym a \code{character} specifying whether to include columns identifying potential acronyms. Acronyms are identified in two first. First, responses are checked against a Wikipedia list ("https://en.wikipedia.org/wiki/Lists_of_acronyms"). Matching of the original and lower-case responses triggers "likely an acronym" and "potentially an acronym". The matched acronym is spelled out in an additional column named \code{acronym_candidate}. Second, the a simple acronym detection based on letter casing also triggers "likely an acronym" but does not produce values in \code{acronym_candidate}. Default is \code{TRUE}.
#'
#' @return Writes a .CSV file containing a list of unique responses plus additional information.
#'
#' @references Aeschbach, S., Mata, R., Wulff, D. U. (in preparation)
#'
#' @examples
#'
#' ar_obj = ar_import(intelligence,
#'                    participant = participant_id,
#'                    cue = cue,
#'                    response = response,
#'                    participant_vars = c(gender, education),
#'                    response_vars = c(response_position, response_level)) %>%
#'   ar_normalize_manual(trimws, which = "left")
#'
#' ar_wordlist_export(ar_obj)
#'
#'@export

ar_wordlist_export = function(associations,
                              file = "wordlist_correction.csv",
                              check_spelling = TRUE,
                              check_acronym = TRUE){

  # checks
  check_object(associations)
  chk::chk_character(file)
  chk::chk_logical(check_spelling)
  chk::chk_logical(check_acronym)

  # check if targets exist
  if("targets" %in% names(associations)) warning("Spell checking should be performed prior to setting targets.")

  # add csv if necessary
  if(stringr::str_sub(stringr::str_to_lower(file), nchar(file)-3, nchar(file)) != ".csv") file = paste0(file, ".csv")

  # response tab
  tab = table(associations$responses$response)

  # construct tibble
  out = tibble::tibble(response = names(tab),
                       response_correct = rep("", length(tab)),
                       response_frequency = c(tab))

  # spelling
  if (check_spelling) {
    pos = spelling::spell_check_text(out$response)$found %>% unlist() %>% unique()
    out$spelling_check = ifelse((1:nrow(out)) %in% pos, "likely misspelled", "")
    }

  # acronym
  if (check_acronym) {

    acronym_dict = acronyms %>% dplyr::pull(meaning, acronym)
    acronym_dict_lower = acronyms %>%
      dplyr::mutate(acronym = stringr::str_to_lower(acronym)) %>%
      dplyr::pull(meaning, acronym)


    out = out %>%
      dplyr::mutate(acronym_check = dplyr::case_when(
                    response %in% names(acronym_dict) ~ "likely an acronym",
                    detect_acronym(response) ~ "likely an acronym",
                    response %in% names(acronym_dict_lower) ~ "potentially an acronym",
                    TRUE ~ ""))

    out = out %>%
      dplyr::mutate(acronym_candidate = dplyr::case_when(
        response %in% names(acronym_dict) ~  acronym_dict[out$response],
        response %in% names(acronym_dict_lower) ~  acronym_dict_lower[out$response],
        TRUE ~  "",
      ))

    }

  # write spelling
  readr::write_csv(out, file)

  }


#' Import wordlist
#'
#' \code{ar_wordlist_import()} import a table of responses from manual spelling correction.
#'
#' @param associations an \code{associatoR} object containing association data as generated by \link[associatoR]{ar_import}.
#' @param file a \code{character} string specifying the filename containing the file spelling correction table exported by \link[associatoR]{ar_wordlist_export}. Must be a .CSV file and contain columns \code{c("response", "response_correct")}. Default name is \code{"wordlist_correction.csv"}.
#' @param process_cues a \code{logical} indicating if cues should be processed (i.e. changed by \code{fun}) or not.
#' @param na a \code{character} vector indicating the values signifying invalid values. Devaults to \code{c("NA")}.
#'
#' @return Writes a .CSV file containing a list of unique responses plus additional information.
#'
#' @references Aeschbach, S., Mata, R., Wulff, D. U. (in preparation)
#'
#' @examples
#'
#' ar_obj = ar_import(intelligence,
#'                    participant = participant_id,
#'                    cue = cue,
#'                    response = response,
#'                    participant_vars = c(gender, education),
#'                    response_vars = c(response_position, response_level)) %>%
#'   ar_normalize_manual(trimws, which = "left")
#'
#' ar_wordlist_import(ar_obj)
#'
#'@export

ar_wordlist_import = function(associations,
                              file = "wordlist_correction.csv",
                              process_cues = TRUE,
                              na = c("NA")) {

  # checks
  check_object(associations)
  chk::chk_character(file)
  chk::chk_file(file)

  # check if targets exist
  if("targets" %in% names(associations)) warning("Spell checking should be performed prior to setting targets.")

  # response tab
  wordlist = readr::read_csv(file, na = na, guess_max = Inf) %>%
    dplyr::mutate_all(function(x) {if(all(is.na(x))) x = ""; x})

  # check
  if(!all(c("response","response_correct") %in% names(wordlist))){
    stop('Wordlist file must contain columns c("response","response_correct")')
    }

  # setup dict
  dictionary = wordlist %>%
    dplyr::filter(is.na(response_correct) | response_correct != "") %>%
    dplyr::rename(old = response,
                  new = response_correct) %>%
    dplyr::select(old, new)

  # correct
  associations = ar_normalize_dict(associations,
                                   dictionary,
                                   process_cues = process_cues)

  # out
  associations

}
