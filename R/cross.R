#' Create participant-targets cross tables
#'
#' \code{ar_cross_targets} creates tables counting targets among responses, for each combination of participant varable groups seperately.
#'
#' @param associations an \code{associatoR} object containing association data as generated by \link[associatoR]{ar_import} with targets defined by \link[associatoR]{ar_set_targets}.
#' @param participant_vars a variable name vector specifying the participant varables to group counts with.
#' @param target_var a variable name specifying the targets variable group counts with.
#' @param normalize a \code{logical} scalar, indicating if counts should be normalized to the participant varable groups. Defaults to \code{FALSE}.
#'
#' @return Returns a \link[tibble]{tibble} containing grouped counts, or grouped counts normalized within participant variable groups if \code{normalize = TRUE}.
#' @export
#'
#' @examples
#' # one participant variable, no normalization
#' ar_import(intelligence,
#'           participant = participant_id,
#'           cue = cue,
#'           response = response,
#'           participant_vars = c(gender, education),
#'           response_vars = c(response_position, response_level)) %>%
#'   ar_set_targets(targets = "cues") %>%
#'   ar_embed_targets() %>%
#'   ar_cluster_targets() %>%
#'   ar_cross_targets(participant_vars = gender, target_var = cluster)
#'
#' # two participant variables, normalized
#' ar_import(intelligence,
#'           participant = participant_id,
#'           cue = cue,
#'           response = response,
#'           participant_vars = c(gender, education),
#'           response_vars = c(response_position, response_level)) %>%
#'   ar_set_targets(targets = "cues") %>%
#'   ar_embed_targets() %>%
#'   ar_cluster_targets() %>%
#'   ar_cross_targets(participant_vars = c(gender, education), target_var = cluster, normalize = TRUE)
ar_cross_targets <- function(associations,
                             participant_vars,
                             target_var,
                             normalize = FALSE) {

  # get vars and check
  p_vars = rlang::enquo(participant_vars)
  t_var = rlang::enquo(target_var)

  # checks
  check_object(associations)
  check_targets(associations)
  check_tidy(associations$participants, p_vars, data_label = "participants")
  check_tidy(associations$targets, t_var, data_label = "targets")
  chk::chk_logical(normalize)

  # get groups, if naming conflict, give priority to $targets name
  data = associations$responses %>%
    dplyr::left_join(associations$participants %>% dplyr::select(id, !!p_vars), by = "id") %>%
    dplyr::filter(response %in% associations$targets$target) %>%
    dplyr::left_join(associations$targets, by = c("response" = "target"), suffix = c(".x", "")) %>%
    dplyr::mutate(target = response)

  # tabluate data
  if (normalize) {
    # return counts normalized for participant variable groups

    # get sums
    sum = data %>%
      dplyr::group_by(dplyr::across(c(!!p_vars, !!t_var))) %>%
      dplyr::summarize(n = length(!!t_var)) %>%
      dplyr::group_by(dplyr::across(c(!!p_vars))) %>%
      dplyr::summarize(sum = sum(n))

    # get normalized counts
    out = data %>%
      dplyr::group_by(dplyr::across(c(!!p_vars, !!t_var))) %>%
      dplyr::summarize(n = length(!!t_var)) %>%
      dplyr::ungroup() %>%
      dplyr::left_join(sum) %>%
      dplyr::mutate(proportion = n / sum) %>%
      dplyr::select(-c(n, sum)) %>%
      suppressMessages()

  } else {
    # return counts
    out = data %>%
      dplyr::group_by(dplyr::across(c(!!p_vars, !!t_var))) %>%
      dplyr::summarize(n = length(!!t_var)) %>%
      dplyr::ungroup()
  }

  # out
  out

}


