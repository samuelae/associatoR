#' Normalize responses in an associatoR object manually
#'
#' \code{ar_normalize_manual(x, fun, ...)} offers an interface to add self-defined normalization steps for responses in associatoR objects.
#'
#' @param x an \code{associatoR} object generated by associatoR::ar_import()
#' @param case one of \code{c("lower", "upper", "original"), converts the resp_text to the specified casing, \code{"original"} does not change the casing.}
#' @param fun a \code{function} to apply to all responses (resp_text) in an associatoR object.
#' @param ... additional arguments passed on to \code{fun}.
#'
#' @return Returns an \code{associatoR} object containing a list of \code{tibble}s with \code{fun} applied to all responses:
#' \describe{
#'  \item{participants}{A tibble of all participants including \code{part_id}, and potentially additional participant-specific attributes \code{part_*}.}
#'  \item{cues}{A tibble of all cues including \code{cue_id}, \code{cue_text} and potentially additional cue-specific attributes \code{cue_*}.}
#'  \item{responses}{A tibble of all responses including \code{resp_id}, \code{resp_text} and potentially additional response-specific attributes \code{resp_*}.}
#' }
#'
#' @export
#'
#' @references Aeschbach, S., Mata, R., Wulff, D. U. (in progress). associatoR. psyArXiv
#'
#' @examples
#'
#' ai_asso_processed <- ar_normalize_manual(ai_asso_processed, tolower)
#'
#' ai_asso_processed <- ar_normalize_manual(ai_asso_processed, trimws, which = "left")
#'
ar_normalize_manual <- function(x, fun, ...) {

  # check if x is an object of class associatoR
  if(!(class(x) == "associatoR")) {
    stop("x must be an object of class associatoR, can be generated with associatoR::ar_import()")
  }

  # check if fun is a function
  if(!class(fun) == "function") {
    stop("fun must be a function")
  }

  args <- c(...)

  if(length(args) == 0) {
    x$responses$resp_text <- sapply(x$responses$resp_text,
                                    FUN = fun,
                                    USE.NAMES = FALSE)
  } else {
    x$responses$resp_text <- sapply(x$responses$resp_text,
                                    FUN = fun,
                                    ...,
                                    USE.NAMES = FALSE)
  }

  x

}

#' Normalize responses in an associatoR object
#'
#' \code{ar_normalize} offers a set of often used normalization steps with sensible defaults and wraps around \code{ar_normalize_manual}.
#'
#' @param x an \code{associatoR} object generated by \code{associatoR::ar_import()}
#' @param case one of \code{c("lower", "upper", "original")}, converts the resp_text to the specified casing, \code{"original"} does not change the casing.
#' @param punct one of \code{c("end", "all", "original")}, \code{end} replaces all punctuation at the end (or only followed by whitespace) of the string with whitespace, \code{"all"} replaces all punctuation characters in the string by whitespace, \code{"original"} changes nothing.
#' @param whitespace one of \code{c("squish", "trim", "original")}, \code{"squish"} removes whitespace from the ends of the string, an reduces multiple whitespace between characters to one, \code{"trim"} removes whitespace from the ends of the string, \code{"original"} keeps whitespaces as is (note that additional whitespaces can be generated based on the string passed to the \code{punct} argument).
#'
#' @return Returns an \code{associatoR} object containing a list of \code{tibble}s with \code{fun} applied to all responses:
#' \describe{
#'  \item{participants}{A tibble of all participants including \code{part_id}, and potentially additional participant-specific attributes \code{part_*}.}
#'  \item{cues}{A tibble of all cues including \code{cue_id}, \code{cue_text} and potentially additional cue-specific attributes \code{cue_*}.}
#'  \item{responses}{A tibble of all responses including \code{resp_id}, \code{resp_text} and potentially additional response-specific attributes \code{resp_*}.}
#' }
#' @export
#'
#' @examples
#'
#' ai_asso_processed <- ar_normalize(ai_asso_processed)
#' ai_asso_processed <- ar_normalize(ai_asso_processed, case = "original",
#'                                   punct = "all")
#'
ar_normalize <- function(x, case = "lower", punct = "end", whitespace = "squish") {

  # check if x is an object of class associatoR
  if(!(class(x) == "associatoR")) {
    stop("x must be an object of class associatoR, can be generated with associatoR::ar_import()")
  }

  # check if case has length one and is one of c("lower", "upper", "original")
  if(length(case) == 1) {
    if(!(case %in% c("lower", "upper", "original"))) {
      stop("argument case must be one of c(\"lower\", \"upper\", \"original\")")
    }
  } else {
    stop("argument case must be of length 1")
  }

  # apply casing
  switch(case,
         "lower" = {x <- ar_normalize_manual(x, stringr::str_to_lower)},
         "upper" = {x <- ar_normalize_manual(x, stringr::str_to_upper)})

  # apply handling of punctuation
  switch(punct,
         "all" = {x <- ar_normalize_manual(x, str_replace_all,
                                           pattern = "[:punct:]",
                                           replacement = " ")},
         "end" = {
           punct_end <- function(strings) {
             str_replace_all(strings, pattern = "[:punct:]*$", replacement = " ") %>%
               str_replace_all(pattern = "[:punct:]*[:blank:]*$", replacement = " ")
           }
           x <- ar_normalize_manual(x, punct_end)
         })

  # apply handing of whitespace
  switch(whitespace,
         "trim" = {x <- ar_normalize_manual(x, stringr::str_trim)},
         "squish" = {x <- ar_normalize_manual(x, stringr::str_squish)})

  x
}


