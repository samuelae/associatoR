#' Normalize responses manually
#'
#' \code{ar_normalize_manual} offers an interface to add self-defined normalization steps for responses (and cues) in \code{associatoR} objects.
#'
#' @param associations an \code{associatoR} object containing association data as generated by \link[associatoR]{ar_import}.
#' @param fun a vectorized \code{function} applied to all responses and cues in the response matrix, excluding cues that exist in the .
#' @param ... additional arguments passed to \code{fun}.
#' @param process_cues a \code{logical} indicating if cues should be processed (i.e. changed by \code{fun}) or not.
#'
#' @return Returns an \code{associatoR} object containing a list of tibbles:
#'
#' \describe{
#'  \item{participants}{A tibble of participants including a participant \code{id} and potential participant attributes.}
#'  \item{cues}{A tibble of cues including a \code{cue} variable and potential cue attributes.}
#'  \item{responses}{A tibble of responses including a participant id, the cues, the responses, the response level, and additional response attributes. All responses are passed through \code{fun}}
#' }
#'
#' @references Aeschbach, S., Mata, R., Wulff, D. U. (in progress)
#'
#' @examples
#'
#' ar_import(intelligence,
#'           participant = participant_id,
#'           cue = cue,
#'           response = response,
#'           participant_vars = c(gender, education),
#'           response_vars = c(response_position, response_level)) %>%
#'   ar_normalize_manual(trimws, which = "left")
#'
#'@export

ar_normalize_manual <- function(associations, fun, ..., process_cues = FALSE) {

  # checks
  check_object(associations)
  chk::chk_function(fun)
  chk::chk_logical(process_cues)

  # normalize ----

  # process cues (conditional on `process_cues`)
  if (process_cues) {

    # add cue_orig
    if(!"cue_orig" %in% names(associations$cues)){
      associations$cues$cue_orig = associations$cues$cue
      associations$responses$cue_orig = associations$responses$cue
    }
    associations$cues$cue <- fun(associations$cues$cue, ...)
    associations$responses$cue <- fun(associations$responses$cue, ...)
  }

  # add response original
  if(!"response_orig" %in% names(associations$responses)){
    associations$responses$response_orig = associations$responses$response
  }

  # process responses
  associations$responses$response <- fun(associations$responses$response, ...)

  # out ----
  associations

}

#' Normalize responses using dictionary
#'
#' \code{ar_normalize_manual} offers an interface to add self-defined normalization steps for responses (and cues) in \code{associatoR} objects.
#'
#' @param associations an \code{associatoR} object containing association data as generated by \link[associatoR]{ar_import}.
#' @param dict a \code{data.frame} consisting of two columns named \code{c("old","new")}.
#' @param process_cues a \code{logical} indicating if cues should be processed (i.e. changed by \code{fun}) or not.
#'
#' @return Returns an \code{associatoR} object containing a list of tibbles:
#'
#' \describe{
#'  \item{participants}{A tibble of participants including a participant \code{id} and potential participant attributes.}
#'  \item{cues}{A tibble of cues including a \code{cue} variable and potential cue attributes.}
#'  \item{responses}{A tibble of responses including a participant id, the cues, the responses, the response level, and additional response attributes. All responses are passed through \code{fun}}
#' }
#'
#' @references Aeschbach, S., Mata, R., Wulff, D. U. (in progress)
#'
#' @examples
#'
#' dict = tibble(old = c("intelligence", "iq"),
#'               new = c("Intelligence", "IQ"))
#'
#' ar_import(intelligence,
#'           participant = participant_id,
#'           cue = cue,
#'           response = response,
#'           participant_vars = c(gender, education),
#'           response_vars = c(response_position, response_level)) %>%
#'   ar_normalize_dict(dict)
#'
#'@export

ar_normalize_manual <- function(associations, fun, ..., process_cues = FALSE) {

  # checks
  check_object(associations)
  chk::chk_function(fun)
  chk::chk_logical(process_cues)

  # normalize ----

  # process cues (conditional on `process_cues`)
  if (process_cues) {

    # add cue_orig
    if(!"cue_orig" %in% names(associations$cues)){
      associations$cues$cue_orig = associations$cues$cue
      associations$responses$cue_orig = associations$responses$cue
    }
    associations$cues$cue <- fun(associations$cues$cue, ...)
    associations$responses$cue <- fun(associations$responses$cue, ...)
  }

  # add response original
  if(!"response_orig" %in% names(associations$responses)){
    associations$responses$response_orig = associations$responses$response
  }

  # process responses
  associations$responses$response = fun(associations$responses$response, ...)

  # out ----
  associations

}



#' Normalize responses
#'
#' \code{ar_normalize} performs normalization steps for responses (and cues) and wraps around \link[associatoR]{ar_normalize_manual}.
#'
#' @param associations an \code{associatoR} object containing association data as generated by \link[associatoR]{ar_import}.
#' @param case a \code{character} specifying the normalization of cases or \code{NULL} to not change casing. Must be one of \code{c("lower", "upper", "sentence", "most_frequent")} or \code{NULL}. Setting \code{case = "lower"} normalizes all responses to lower case, \code{case = "lower"} to upper case, \code{case = "sentence"} to sentence case, and \code{case = "most_frequent"} to the most frequent casing for each string.
#' @param punct a \code{character} specifying the normalization of punctuationor \code{NULL} to not change punctuation. Must be one of \code{c("end", "all")} or \code{NULL}. \code{punct = "end"} replaces all punctuation at the end (including following whitespaces) with \code{punct_replacement} (default is a single white space). \code{punct = "all"} replaces all punctuation.
#' @param punct_replacement a \code{character} used as replacement for punctuation.
#' @param whitespace a \code{character} specifying the normalization of white spaces or \code{NULL} to not change whitespace. Must be one of \code{c("squish", "trim")} or \code{NULL}. Setting \code{whitespace = "squish"} removes additional white spaces at the start, the end, and in-between words, whereas setting \code{whitespace = "trim"} removes white space from the start and end.
#' @param process_cues a \code{logical} specifying, if cues should be processed as well. Defaults to \code{FALSE}.
#'
#' @return Returns an \code{associatoR} object containing a list of tibbles:
#' \describe{
#'  \item{participants}{A tibble of participants including a participant \code{id} and potential participant attributes.}
#'  \item{cues}{A tibble of cues including a \code{cue} variable and potential cue attributes.}
#'  \item{responses}{A tibble of responses including a participant id, the cues, the responses, the response level, and additional response attributes.}
#' }
#'
#' @references Aeschbach, S., Mata, R., Wulff, D. U. (in progress)
#'
#' @examples
#'
#' ar_import(intelligence,
#'           participant = participant_id,
#'           cue = cue,
#'           response = response,
#'           participant_vars = c(gender, education),
#'           response_vars = c(response_position, response_level)) %>%
#'   ar_normalize(case = "lower", punct = "all")
#'
#' @export

ar_normalize <- function(associations,
                         case = "majority",
                         punct = "end",
                         punct_replacement = " ",
                         whitespace = "squish",
                         process_cues = TRUE) {

  # checks ----

  # associations
  check_class(associations)
  chk::chk_string(case)
  chk::chk_subset(case, c("lower", "upper", "sentence", "most_frequent"))

  # case ----

  if (!is.null(case)){
    if (case == "lower") {
      associations <- ar_normalize_manual(associations, stringr::str_to_lower,
                                          process_cues = process_cues)
    }

    if (case == "upper") {
      associations <- ar_normalize_manual(associations, stringr::str_to_upper,
                                          process_cues = process_cues)
    }

    if (case == "sentence") {
      associations <- ar_normalize_manual(associations, stringr::str_to_sentence,
                                          process_cues = process_cues)
    }
    if (case == "most_frequent") {

      # process responses
      associations$responses$response <- to_frequent(associations$responses$response)

      if (process_cues == TRUE) {
        # get correct casing for all cues
        lookup <- tibble::tibble(cue_original = associations$responses$cue,
                                 cue_lower = tolower(associations$responses$cue)) %>%
          dplyr::distinct()
        lookup <- lookup %>%
          dplyr::left_join(associations$responses %>%
                             dplyr::mutate(response_lower = tolower(response)) %>%
                             dplyr::select(response, response_lower) %>%
                             dplyr::distinct(),
                           by = c("cue_lower" = "response_lower")) %>%
          dplyr::select(cue_original, cue_most_frequent = response)

        # set cue casing in responses tibble
        associations$responses$cue <- sapply(associations$responses$cue,
                                             function(x) {lookup$cue_most_frequent[lookup$cue_original == x]})

        # set cue casing in cues tibble and keep distinct cues
        associations$cues$cue <- sapply(associations$cues$cue,
                                        function(x) {lookup$cue_most_frequent[lookup$cue_original == x]})
        associations$cues <- dplyr::distinct(associations$cues)

      }

    }

  }

  # punct ----

  if (!is.null(punct)){
    if (punct == "all") {
      associations <- ar_normalize_manual(associations,
                                          stringr::str_replace_all,
                                          pattern = "[:punct:]+",
                                          replacement = punct_replacement,
                                          process_cues = process_cues)
    }

    if (punct == "end") {
      associations <- ar_normalize_manual(associations,
                                          stringr::str_replace_all,
                                          pattern = "[:punct:]+[:blank:]*$",
                                          replacement = punct_replacement,
                                          process_cues = process_cues)
    }
  }


  # whitespace ----

  if (!is.null(whitespace)) {
    if (punct == "trim") {
      associations <- ar_normalize_manual(associations, stringr::str_trim,
                                          process_cues = process_cues)
    }
    if (punct == "squish") {
      associations <- ar_normalize_manual(associations, stringr::str_squish,
                                          process_cues = process_cues)
    }
  }


  # case ----

  if(!is.null(case)){
    if(case == "majority"){

      dict = associations$responses %>%
        dplyr::mutate(response_lower = stringr::str_to_lower(response)) %>%
        dplyr::count(response_lower, response) %>%
        dplyr::group_by(response_lower) %>%
        dplyr::mutate(response_choose = names(sort(table(response),decreasing = TRUE)[1])) %>%
        dplyr::ungroup() %>%
        dplyr::pull(response_choose, response)

      associations
      associations <- ar_normalize_manual(associations, stringr::str_to_lower,
                                          process_cues = process_cues)
    }

    if(case == "lower"){
      associations <- ar_normalize_manual(associations, stringr::str_to_lower,
                                          process_cues = process_cues)
    }

    if(case == "upper"){
      associations <- ar_normalize_manual(associations, stringr::str_to_upper,
                                          process_cues = process_cues)
    }

    if(case == "sentence"){
      associations <- ar_normalize_manual(associations, stringr::str_to_sentence,
                                          process_cues = process_cues)
    }
  }

  # out ----
  associations

}
