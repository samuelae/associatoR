#' Normalize words in an associatoR object manually
#'
#' \code{ar_normalize_manual} offers an interface to add self-defined normalization steps for responses (and cues) in associatoR objects.
#'
#' @param x an \code{associatoR} object generated by associatoR::ar_import()
#' @param fun a \code{function} to apply to all responses (resp_text) in an associatoR object.
#' @param normalize_cues (\code{FALSE}) change to \code{TRUE} to apply \code{fun} to cues as well.
#' @param ... additional arguments passed on to \code{fun}.
#'
#' @return Returns an \code{associatoR} object containing a list of tibbles:
#' \describe{
#'  \item{participants}{A tibble of all participants including \code{p_id} to identify participants, and potentially additional participant attributes \code{p_attr_*}.}
#'  \item{cues}{A tibble of all cues \code{c_cue} and potentially additional cue attributes \code{c_attr_*}.}
#'  \item{responses}{A tibble of all participant's \code{p_id} cue \code{r_cue} and response \code{r_response} pairs including response levels \code{r_level}, as well as potentially additional responseattributes \code{r_attr_*}.}
#' }
#'
#' @export
#'
#' @references Aeschbach, S., Mata, R., Wulff, D. U. (in progress)
#'
#' @examples
#'
#' ai_asso_processed <- ar_normalize_manual(ai_asso_imported, tolower)
#' ai_asso_processed <- ar_normalize_manual(ai_asso_imported, trimws, which = "left")
#'
ar_normalize_manual <- function(x, fun, normalize_cues = FALSE, ...) {

  # check ----------------------------------------------------------------------

  # x
  chk::chk_s3_class(x, "associatoR")

  # fun
  chk::chk_function(fun)

  # normalize_cues
  chk::chk_flag(normalize_cues)

  # function body --------------------------------------------------------------

  # cache ... arguments
  args <- c(...)

  # apply fun (including ...) to responses
  if(length(args) == 0) {
    # normalize responses
    x$responses$r_response <- sapply(x$responses$r_response,
                                     FUN = fun,
                                     USE.NAMES = FALSE)
    if (normalize_cues) {
      # normalize cues in responses tibble
      x$responses$r_cue <- sapply(x$responses$r_cue,
                                  FUN = fun,
                                  USE.NAMES = FALSE)
      # normalize cues in cues tibble, keep all entries
      x$cues$c_cue <- sapply(x$cues$c_cue,
                             FUN = fun,
                             USE.NAMES = FALSE)
      # keep distinct entries in cues tibble
      x$cues <- x$cues %>% dplyr::distinct()

    }
  } else {
    # normalize responses
    x$responses$r_response <- sapply(x$responses$r_response,
                                     FUN = fun,
                                     ...,
                                     USE.NAMES = FALSE)
    if (normalize_cues) {
      # normalize cues in responses tibble
      x$responses$r_cue <- sapply(x$responses$r_cue,
                                  FUN = fun,
                                  ...,
                                  USE.NAMES = FALSE)
      # normalize cues in cues tibble, keep all entries
      x$cues$c_cue <- sapply(x$cues$c_cue,
                             FUN = fun,
                             ...,
                             USE.NAMES = FALSE)
      # keep distinct entries in cues tibble
      x$cues <- x$cues %>% dplyr::distinct()
    }
  }

  x

}

#' Normalize words in an associatoR object
#'
#' \code{ar_normalize} inlcludes often used normalization steps for responses (and cues) and wraps around \code{ar_normalize_manual}.
#'
#' @param x an \code{associatoR} object generated by \code{associatoR::ar_import()}
#' @param case one of \code{c("lower", "upper", "original")}, converts the responses (and cues) to the specified casing, \code{"original"} does not change the casing.
#' @param punct one of \code{c("end", "all", "original")}, \code{end} replaces all punctuation at the end (or only followed by whitespace) of the string with whitespace, \code{"all"} replaces all punctuation characters in the string by whitespace, \code{"original"} changes nothing.
#' @param whitespace one of \code{c("squish", "trim", "original")}, \code{"squish"} removes whitespace from the ends of the string, an reduces multiple whitespace between characters to one, \code{"trim"} removes whitespace from the ends of the string, \code{"original"} keeps whitespaces as is (note that additional whitespaces can be generated based on the string passed to the \code{punct} argument).
#' @param normalize_cues (\code{FALSE}) change to \code{TRUE} to apply normalization steps to cues as well.
#'
#'
#' @return Returns an \code{associatoR} object containing a list of tibbles:
#' \describe{
#'  \item{participants}{A tibble of all participants including \code{p_id} to identify participants, and potentially additional participant attributes \code{p_attr_*}.}
#'  \item{cues}{A tibble of all cues \code{c_cue} and potentially additional cue attributes \code{c_attr_*}.}
#'  \item{responses}{A tibble of all participant's \code{p_id} cue \code{r_cue} and response \code{r_response} pairs including response levels \code{r_level}, as well as potentially additional responseattributes \code{r_attr_*}.}
#' }
#' @export
#'
#' @references Aeschbach, S., Mata, R., Wulff, D. U. (in progress)
#'
#' @examples
#'
#' ai_asso_processed <- ar_normalize(ai_asso_imported)
#' ai_asso_processed <- ar_normalize(ai_asso_imported, case = "original",
#'                                   punct = "all")
#'
ar_normalize <- function(x, case = "lower", punct = "end", whitespace = "squish",
                         normalize_cues = FALSE) {

  # checks ---------------------------------------------------------------------

  # x
  chk::chk_s3_class(x, "associatoR")

  # case
  chk::chk_length(case, 1)
  chk::chk_subset(case, c("lower", "upper", "original"))

  # punct
  chk::chk_length(punct, 1)
  chk::chk_subset(punct, c("end", "all", "original"))

  # whitespace
  chk::chk_length(whitespace, 1)
  chk::chk_subset(whitespace, c("squish", "trim", "original"))

  # normalize_cues
  chk::chk_flag(normalize_cues)

  # function body --------------------------------------------------------------

  # apply casing
  switch(case,
         "lower" = {x <- ar_normalize_manual(x, stringr::str_to_lower, normalize_cues = normalize_cues)},
         "upper" = {x <- ar_normalize_manual(x, stringr::str_to_upper, normalize_cues = normalize_cues)})

  # apply handling of punctuation
  switch(punct,
         "all" = {x <- ar_normalize_manual(x, stringr::str_replace_all,
                                           normalize_cues = normalize_cues,
                                           pattern = "[:punct:]",
                                           replacement = " ")},
         "end" = {
           punct_end <- function(strings) {
             stringr::str_replace_all(strings, pattern = "[:punct:]*$", replacement = " ") %>%
               stringr::str_replace_all(pattern = "[:punct:]*[:blank:]*$", replacement = " ")
           }
           x <- ar_normalize_manual(x, punct_end, normalize_cues = normalize_cues)
         })

  # apply handing of whitespace
  switch(whitespace,
         "trim" = {x <- ar_normalize_manual(x, stringr::str_trim, normalize_cues = normalize_cues)},
         "squish" = {x <- ar_normalize_manual(x, stringr::str_squish, normalize_cues = normalize_cues)})

  x
}


