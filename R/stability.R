#' Cluster stability
#'
#' \code{ar_cluster_stability} evaluates the stability of a clustering generated by ar_cluster_targets()
#'
#' Clustering stability is calculated with the identical clustering settings (e.g., clustering algorithm, similarity function, etc.) used to generate the original cluster assignment. The information is stored as a attribute to the \code{targets} table with name \code{"cluster_settings"}.
#'
#' @param associations an \code{associatoR} object including target_embeddings.
#' @param n_boot an \code{integer} specifying the number of bootstrap samples to draw. Default is \code{1000}.
#' @param unique a \code{logical} specifying whether duplicate targets in bootstrap shouod be ignored. Default is \code{TRUE}.
#'
#' @return The function returns a list containing two matrices with the target- (\code{target_stability}) and cluster-wise (\code{cluster_stability}) probabilities of being assigned to the same cluster under random pertubation.
#'
#' @examples
#' ar_obj = ar_import(intelligence,
#'                    participant = participant_id,
#'                    cue = cue,
#'                    response = response,
#'                    participant_vars = c(gender, education),
#'                    response_vars = c(response_position, response_level)) %>%
#'   ar_set_targets(targets = "cues") %>%
#'   ar_embed_targets() %>%
#'   ar_cluster_targets(method = "louvain")
#'
#' ar_cluster_stability(ar_obj)
#'
#' @export
ar_cluster_stability <- function(associations, n_boot = 1000, unique = FALSE) {

  # check inputs
  check_object(associations)
  check_targets(associations)
  check_embeddings(associations)

  # get embedding
  emb = associations$target_embedding[, -1] %>% as.matrix()
  rownames(emb) = associations$target_embedding %>% dplyr::pull(target)

  # get settings
  cluster_setting = attr(associations$targets, "cluster_settings")

  # setup container
  results = expand.grid(i = 1:nrow(emb), j = 1:nrow(emb)) %>%
    tibble::as_tibble() %>%
    dplyr::filter(i < j) %>%
    dplyr::mutate(id = get_id(rownames(emb)[i], rownames(emb)[j]),
                  count = 0,
                  stab = 0) %>%
    dplyr::select(id, count, stab)

  # mutable object
  associations_boot = associations
  associations_boot$boot = TRUE

  # setup progress bar
  bar = progress::progress_bar$new(format = "Running bootstrap [:bar] :percent eta: :eta", total = 100, clear = FALSE, width= 60)
  bar$tick(0)

  for(i in 1:n_boot){

    # sample
    if(unique){
      size = round(nrow(emb) * (1-1/exp(1)))
      targets = sample(rownames(emb), size = size, replace = FALSE)
      } else {
      targets = sample(rownames(emb), replace = TRUE)
      }

    # overwrite_embeddings
    associations_boot$target_embedding = tibble(target = targets) %>% bind_cols(as_tibble(emb[targets,]))

    # run clustering
    clustering = do.call(ar_cluster_targets,
                         c(list(associations = associations_boot), cluster_setting))

    # evaluate sameness
    equal = cstab:::equal(clustering$cluster)

    # evaluate sameness
    equal_tbl = expand.grid(i = 1:length(targets), j = 1:length(targets)) %>%
      as_tibble() %>%
      filter(i < j) %>%
      arrange(i, j) %>%
      mutate(i = targets[i],
             j = targets[j],
             id = get_id(i, j),
             equal = equal) %>%
      group_by(id) %>%
      summarize(count = n(),
                stab = sum(equal))

    # add to counts
    results = results %>%
      left_join(equal_tbl, by = c("id"), suffix = c("","_new")) %>%
      mutate(count = count + ifelse(is.na(count_new), 0, count_new),
             stab = stab + ifelse(is.na(stab_new), 0, stab_new)) %>%
      select(-count_new, -stab_new)


    # update bar
    bar$update(i/n_boot)

    }

  # get original clusters from data
  clusters = associations$targets %>% pull(cluster, target)

  # evaluate
  results = results %>%
    dplyr::mutate(i = str_split(id, "_") %>% sapply(`[`, 1),
                  j = str_split(id, "_") %>% sapply(`[`, 2)) %>%
    dplyr::select(i, j, count, stab) %>%
    dplyr::mutate(i_cluster = clusters[i],
                  j_cluster = clusters[j],
                  stability = stab / count) %>%
    dplyr::select(i, j, i_cluster, j_cluster, count, stability)

  # expand
  results = results %>%
    dplyr::bind_rows(tibble(i = results$j,
                            j = results$i,
                            i_cluster = results$j_cluster,
                            j_cluster = results$i_cluster,
                            count = results$count,
                            stability = results$stability))

  # aggregate within clusters
  results_cluster = results %>%
    dplyr::group_by(i_cluster, j_cluster) %>%
    dplyr::summarize(stability = mean(stability)) %>%
    dplyr::ungroup()

  # output matrix target
  target_unique = names(clusters)[!is.na(clusters)]
  target_stability = matrix(nrow = length(target_unique),
                            ncol = length(target_unique),
                            dimnames = list(target_unique, target_unique))
  target_stability[cbind(results$i,results$j)] = results$stability
  diag(target_stability) = 1

  # output matrix cluster
  cluster_unique = na.omit(unique(clusters))
  cluster_stability = matrix(nrow = length(cluster_unique),
                             ncol = length(cluster_unique),
                             dimnames = list(cluster_unique, cluster_unique))
  cluster_stability[cbind(results_cluster$i_cluster,results_cluster$j_cluster)] = results_cluster$stability

  # out
  list(target_stability = target_stability,
       cluster_stability = cluster_stability)

  }
