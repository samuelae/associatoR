#' Define target in an associatoR object
#'
#' \code{ar_define_target} defines the target level to further analyze in an associatoR object. This could be multiple cue words to analyze based on responses, response words to analyze based on an external embedding, or response words to analyze based on a second level of responses.
#'
#' @param x an \code{associatoR} object generated by associatoR::ar_import()
#' @param source one of \code{c("cues", "responses")} specifying, which column in $participants contains targets.
#' @param response_level an \code{integer} (\code{1}) specifying, which response-level contains targets.
#'
#' @return Returns an \code{associatoR} object containing a list of tibbles:
#' \describe{
#'  \item{participants}{A tibble of all participants including \code{p_id} to identify participants, and potentially additional participant attributes \code{p_attr_*}.}
#'  \item{cues}{A tibble of all cues \code{c_cue} and potentially additional cue attributes \code{c_attr_*}.}
#'  \item{responses}{A tibble of all participant's \code{p_id} cue \code{r_cue} and response \code{r_response} pairs including response levels \code{r_level}, as well as potentially additional responseattributes \code{r_attr_*}.}
#'  \item{targets}{A tibble of \code{target}s that will be analyzed by subsequent functions.}
#' }
#' @export
#'
#' @examples
#'
#' ai_asso <- ar_define_target(ai_asso_imported, source = "responses")
#'
ar_define_target <- function(x, source = c("cues", "responses"), response_level = 1) {

  # checks ---------------------------------------------------------------------

  # x
  chk::chk_s3_class(x, "associatoR")

  # source
  chk::chk_string(source)
  chk::chk_subset(source, c("cues", "responses"))

  # response_level
  chk::chk_count(response_level)

  # function body --------------------------------------------------------------

  switch (source,
    "cues" = {
      targets <- x$cues %>%
        dplyr::select(c_cue) %>%
        dplyr::distinct() %>%
        dplyr::rename(t_target = c_cue)
    },
    "responses" = {
      targets <- x$responses %>%
        dplyr::filter(r_level == response_level) %>%
        dplyr::select(r_response) %>%
        dplyr::distinct() %>%
        dplyr::rename(t_target = r_response)
    })

  x$targets <- targets

  x

}

#' Add a frequency variable to targets
#'
#' Adds a variable \code{frequency} to the Targets in an associatoR object .
#'
#' @param x an \code{associatoR} object generated by associatoR::ar_import()
#' @param source one of \code{c("cues", "responses")}, specifying where the targets come from.
#'
#' @return
#' @return Returns an \code{associatoR} object containing a list of tibbles:
#' \describe{
#'  \item{participants}{A tibble of all participants including \code{p_id} to identify participants, and potentially additional participant attributes \code{p_attr_*}.}
#'  \item{cues}{A tibble of all cues \code{c_cue} and potentially additional cue attributes \code{c_attr_*}.}
#'  \item{responses}{A tibble of all participant's \code{p_id} cue \code{r_cue} and response \code{r_response} pairs including response levels \code{r_level}, as well as potentially additional responseattributes \code{r_attr_*}.}
#'  \item{targets}{A tibble of \code{target} and \code{frequency} that will be analyzed by subsequent functions.}
#' }
#' @export
#' @examples
#' ar_import(ai_asso, participant_id = "id",
#'                               response_col = "association_correct",
#'                               cue_type = "manual", cue_manual = "artificial intelligence",
#'                               participant_attributes = c("age", "gender", "use", "expertise"),
#'                               response_attributes = c("association", "trial")) %>%
#'   ar_normalize() %>%
#'   ar_define_target(source = "responses") %>%
#'   ar_target_add_frequency(source = "responses")
#'
ar_target_add_frequency <- function(x, source = c("cues", "responses")) {

  # checks ---------------------------------------------------------------------

  # x
  chk::chk_s3_class(x, "associatoR")
  chk::chk_subset("targets", names(x))

  # source
  chk::chk_string(source)
  chk::chk_subset(source, c("cues", "responses"))

  # function body --------------------------------------------------------------

  switch (source,
    "cues" = {
      target_frequency <- x$responses %>%
        dplyr::left_join(x$targets,
                         by = c("r_cue" = "t_target"),
                         keep = TRUE) %>%
        dplyr::group_by(t_target) %>%
        dplyr::summarize(frequency = dplyr::n())
    },
    "responses" = {
      target_frequency <- x$responses %>%
        dplyr::left_join(x$targets,
                         by = c("r_response" = "t_target"),
                         keep = TRUE) %>%
        dplyr::group_by(t_target) %>%
        dplyr::summarize(frequency = dplyr::n())
    }
  )

  x$targets <- x$targets %>%
    dplyr::left_join(target_frequency)

  x
}
