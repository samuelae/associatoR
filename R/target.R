#' Set analysis targets
#'
#' \code{ar_set_target} defines the analysis targets (cues and/or responses).
#'
#' @param associations an \code{associatoR} object containing association data as generated by \link[associatoR]{ar_import}.
#' @param target_sets a \code{character} string or vector specifying whether cues and/or responses should the targets of analysis. Must be one or both of \code{c("cues", "responses")}.
#' @param target_manual a \code{character} character specifying the analysis target. Overrides argument \code{target_sets}.
#'
#' @return Returns an \code{associatoR} object containing a list of tibbles:
#' \describe{
#'  \item{participants}{A tibble of participants including a participant \code{id} and potential participant attributes.}
#'  \item{cues}{A tibble of cues including a \code{cue} variable and potential cue attributes.}
#'  \item{responses}{A tibble of responses including a participant id, the cues, the responses, the response level, and additional response attributes.}
#'  \item{targets}{A tibble of targets including the specified analysis target}
#' }
#'
#'
#' @examples
#'
#' ai_asso <- ai_asso %>%
#'   ar_define_targets(source = "cues")
#'
#' @export

ar_set_targets <- function(associations,
                          target_set = c("cues", "responses"),
                          target_manual = NULL) {

  # checks -----

  # check types
  chk::chk_s3_class(associations, "associatoR")

  # check allowed values
  if(is.null(target_manual)){

    # check if type correct
    chk::chk_character(target_set)
    chk::chk_subset(target_set, c("cues", "responses"))

    # container
    target_vec = c()

    # cues
    if("cues" %in% target_set){
      target_vec = c(target_vec, unique(associations$cues$cue))
    }

    # responses
    if("responses" %in% target_set){
      target_vec = c(target_vec, unique(associations$responses$response))
    }

    # set unique
    target_vec = unique(target_vec)

    } else {

    # check
    chk::chk_character(target_manual)

    # use manual
    target_vec = target_manual
    }

  # out -----

  targets = tibble::tibble(target = target_vec)
  associations$targets <- targets
  associations

  }

#' Append response frequencies
#'
#' Append the response \code{frequency} of each target to the \code{targets} table in the \code{associatoR} object.
#'
#' @param associations an \code{associatoR} object containing association data as generated by \link[associatoR]{ar_import}.
#' @param ... optional \code{logical} comparisons filtering the responses before computing the frequencies.
#'
#' @return Returns an \code{associatoR} object containing a list of tibbles, with \code{targets} gaining a \code{frequency} column:
#' \describe{
#'  \item{participants}{A tibble of participants including a participant \code{id} and potential participant attributes.}
#'  \item{cues}{A tibble of cues including a \code{cue} variable and potential cue attributes.}
#'  \item{responses}{A tibble of responses including a participant id, the cues, the responses, the response level, and additional response attributes.}
#'  \item{targets}{A tibble of targets including the specified analysis target}
#' }
#'
#' @examples
#'
#' ai_asso <- ai_asso %>%
#'   ar_set_targets("responses") %>%
#'   ar_append_frequency()
#'
#' @export

ar_append_frequency <- function(associations, ...) {

  # delay eval
  filters = dplyr::enquos(...)

  # checks
  chk::chk_s3_class(associations, "associatoR")
  chk::chk_subset("targets", names(associations))

  # calc frequency
  frequencies = associations$responses %>%
    dplyr::filter(!!!filters) %>%
    dplyr::group_by(response) %>%
    dplyr::summarize(frequency = n())

  # join
  associations$targets = associations$targets %>%
    dplyr::left_join(frequencies, by = c("target" = "response"))

  # out
  associations
  }
