#' Correlate targets responses with participant variables
#'
#' \code{ar_correlate_targets} calculates the correlations between the response occurrence of \code{targets} and participant variables, such as gender or age.
#'
#' Function calculates the point-biserial correlation for numeric and Cramer's V for categorical \code{participant_vars}.
#'
#' @param associations an \code{associatoR} object containing association data as generated by \link[associatoR]{ar_import}.
#' @param participant_vars a \code{character} vector specifying the participant variables to assess. The variables must exist in \code{associations$participants}.
#' @param metric a \code{character} scalar of \code{c("auto", "point-biserial", "phi", "cramer")} specifying the metric to calculate for the correlation of \code{participant_vars} and targets. Defaults to \code{"auto"}.
#'
#' @return Returns an \code{associatoR} object containing a list of tibbles, with \code{targets} gaining correlation column(s):
#' \describe{
#'  \item{participants}{A tibble of participants including a participant \code{id} and potential participant attributes.}
#'  \item{cues}{A tibble of cues including a \code{cue} variable and potential cue attributes.}
#'  \item{responses}{A tibble of responses including a participant id, the cues, the responses, the response level, and additional response attributes.}
#'  \item{targets}{A tibble of targets including the specified analysis target, and correlation column(s).}
#' }
#'
#' @examples
#' ar_import(intelligence,
#'           participant = participant_id,
#'           cue = cue,
#'           response = response,
#'           participant_vars = c(gender, education),
#'           response_vars = c(response_position, response_level)) %>%
#'   ar_set_targets(targets = "cues") %>%
#'   ar_correlate_targets(participant_vars = c(education, gender))
#'
#' @export
ar_correlate_targets <- function(associations, participant_vars, metric = "auto") {

  # handle input
  participant_vars <- rlang::enquo(participant_vars)

  # checks
  check_object(associations)
  check_targets(associations)
  check_tidy(associations$participants, participant_vars, data_label = "participants")
  chk::chk_subset(metric, c("auto", "point-biserial", "phi", "cramer"))

  # get targets
  targets <- associations$targets$target
  participants <- associations$responses$id %>% as.character()
  responses <- associations$responses$response
  uni_participant <- unique(participants)
  target_participants <- matrix(FALSE,
                                nrow = length(uni_participant),
                                ncol = length(targets),
                                dimnames = list(uni_participant, targets))
  for (i in 1:length(targets)) {
    target_participants[unique(participants[(!is.na(responses)) & responses == targets[i]]),
                        targets[i]] = TRUE
  }

  # do calculations, functions defined in helper.R
  corr_list = list()

  # extract variable names
  p_vars <- associations$participants %>%
    dplyr::select(!!participant_vars) %>%
    names()

  if (metric == "auto") {
    for(i in 1:length(p_vars)) {
      gr = associations$participants[[p_vars[i]]]
      if(is.factor(gr)) gr = as.character(gr)
      if(is.numeric(gr)) {
        corr_list[[p_vars[i]]] = apply(target_participants, 2,
                                       function(x) point_biserial(gr, x))
      } else if(is.character(gr) | is.logical(gr)) {
        if(length(unique(gr)) == 2 | is.logical(gr)) {
          corr_list[[p_vars[i]]] = apply(target_participants, 2,
                                         function(x) phi(gr, x))
        } else {
          corr_list[[p_vars[i]]] = apply(target_participants, 2,
                                         function(x) cramer(gr, x))
        }
      }
    }
  } else if (metric == "point-biserial") {
    for(i in 1:length(p_vars)) {
      gr = associations$participants[[p_vars[i]]]
      if(!is.numeric(gr)) stop("All participant_vars must be numeric for metric \"point-biserial\"")
      if(is.factor(gr)) gr = as.character(gr)
      corr_list[[p_vars[i]]] = apply(target_participants, 2,
                                     function(x) point_biserial(gr, x))
    }
  } else if (metric == "phi") {
    for(i in 1:length(p_vars)) {
      gr = associations$participants[[p_vars[i]]]
      if(is.factor(gr)) gr = as.character(gr)
      corr_list[[p_vars[i]]] = apply(target_participants, 2,
                                     function(x) phi(gr, x))
    }
  } else if (metric == "cramer") {
    for(i in 1:length(p_vars)) {
      gr = associations$participants[[p_vars[i]]]
      if(is.factor(gr)) gr = as.character(gr)
      corr_list[[p_vars[i]]] = apply(target_participants, 2,
                                     function(x) cramer(gr, x))
    }
  }
  corrs <- corr_list %>% tibble::as_tibble()
  names(corrs) <- paste0(names(corrs), "_corr")
  corrs <- corrs %>% dplyr::mutate(target = colnames(target_participants))

  # join
  associations$targets <- associations$targets %>%
    dplyr::left_join(corrs)

  # out
  associations
}
