#' Correlate targets responses with participant variables
#'
#' \code{ar_correlate_targets} calculates the correlations between the response occurrence of \code{targets} and participant variables, such as gender or age.
#'
#' Function calculates the point-biserial correlation for numeric and Cramer's V for categorical \code{participant_vars}.
#'
#' @param associations an \code{associatoR} object containing association data as generated by \link[associatoR]{ar_import}.
#' @param participant_vars a \code{character} vector specifying the participant variables to assess. The variables must exist in \code{associations$participants}.
#'
#' @return Returns an \code{associatoR} object containing a list of tibbles, with \code{targets} gaining correlation column(s):
#' \describe{
#'  \item{participants}{A tibble of participants including a participant \code{id} and potential participant attributes.}
#'  \item{cues}{A tibble of cues including a \code{cue} variable and potential cue attributes.}
#'  \item{responses}{A tibble of responses including a participant id, the cues, the responses, the response level, and additional response attributes.}
#'  \item{targets}{A tibble of targets including the specified analysis target, and correlation column(s).}
#' }
#'
#' @examples
#' ar_import(intelligence,
#'           participant = participant_id,
#'           cue = cue,
#'           response = response,
#'           participant_vars = c(gender, education),
#'           response_vars = c(response_position, response_level)) %>%
#'   ar_set_targets(targets = "cues") %>%
#'   ar_correlate_targets(participant_vars = c("education", "gender"))
#'
#' @export

ar_correlate_targets <- function(associations, participant_vars) {

  # checks
  chk::chk_s3_class(associations, "associatoR")
  chk::chk_subset("targets", names(associations))
  chk::chk_character(participant_vars)
  chk::chk_subset(participant_vars, names(associations$participants))

  # get targets
  targets <- associations$targets$target
  participants <- associations$responses$id %>% as.character()
  responses <- associations$responses$response
  uni_participant <- unique(participants)
  target_participants <- matrix(FALSE,
                                nrow = length(uni_participant),
                                ncol = length(targets),
                                dimnames = list(uni_participant, targets))
  for(i in 1:length(targets)){
    target_participants[unique(participants[(!is.na(responses)) & responses == targets[i]]), targets[i]] = TRUE
  }

  # do calculations, functions defined in helper.R
  corr_list = list()
  for(i in 1:length(participant_vars)) {
    gr = associations$participants[[participant_vars[i]]]
    if(is.factor(gr)) gr = as.character(gr)
    if(is.numeric(gr)) {
      corr_list[[participant_vars[i]]] = apply(target_participants, 2, function(x) point_biserial(gr, x))
    } else if(is.character(gr) | is.logical(gr)) {
      if(length(unique(gr)) == 2 | is.logical(gr)) {
        corr_list[[participant_vars[i]]] = apply(target_participants, 2, function(x) phi(gr, x))
      } else {
        corr_list[[participant_vars[i]]] = apply(target_participants, 2, function(x) cramer(gr, x))
      }
    }
  }
  corrs <- corr_list %>% tibble::as_tibble()
  names(corrs) <- paste0(names(corrs), "_corr")
  corrs <- corrs %>% dplyr::mutate(target = colnames(target_participants))

  # join
  associations$targets <- associations$targets %>%
    dplyr::left_join(corrs)

  # out
  associations
}
