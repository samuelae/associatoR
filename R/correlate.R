#' Correlate targets responses with participant variables
#'
#' \code{ar_correlate_targets} calculates the correlations between the response occurrence of \code{targets} and participant variables, such as gender or age.
#'
#' Function calculates the point-biserial correlation for numeric and Cramer's V for categorical \code{participant_vars}.
#'
#' @param associations an \code{associatoR} object containing association data as generated by \link[associatoR]{ar_import}.
#' @param participant_vars a \code{character} vector specifying the participant variables to assess. The variables must exist in \code{associations$participants}.
#'
#' @return Returns an \code{associatoR} object containing a list of tibbles, with \code{targets} gaining a \code{frequency} column:
#' \describe{
#'  \item{participants}{A tibble of participants including a participant \code{id} and potential participant attributes.}
#'  \item{cues}{A tibble of cues including a \code{cue} variable and potential cue attributes.}
#'  \item{responses}{A tibble of responses including a participant id, the cues, the responses, the response level, and additional response attributes.}
#'  \item{targets}{A tibble of targets including the specified analysis target}
#' }
#'
#' @examples
#'
#' ar_import(risk_asso,
#'           participant = "id",
#'           cue = "cue",
#'           response = "response",
#'           response_vars = "trial",
#'           participant_vars = c("gender", "age", "age_group")) %>%
#'   ar_set_targets("cues") %>%
#'   ar_correlate_targets(participant_vars = c("age", "gender"))
#'
#' @export

ar_correlate_targets <- function(associations, participant_vars) {

  # checks
  chk::chk_s3_class(associations, "associatoR")
  chk::chk_subset("targets", names(associations))
  chk::chk_subset(participant_vars, names(associations$participants))

  # get targets
  targets = associations$targets$target
  participants = associations$responses$id %>% as.character()
  responses = associations$responses$response
  uni_participant = unique(participants)
  target_participants = matrix(FALSE,
                               nrow = length(uni_participant),
                               ncol = length(targets),
                               dimnames = list(uni_participant, targets))
  for(i in 1:length(targets)){
    target_participants[unique(participants[(!is.na(responses)) & responses == targets[i]]), targets[i]] = TRUE
  }

  # do calc
  corr_list = list()
  for(i in 1:length(participant_vars)){
    gr = associations$participants[[participant_vars[i]]]
    if(is.factor(gr)) gr = as.character(gr)
    if(is.numeric(gr)){
      corr_list[[participant_vars[i]]] = apply(target_participants,2,function(x) point_biserial(gr,x))
      } else if(is.character(gr) | is.logical(gr)){
        if(length(unique(gr)) == 2 | is.logical(gr)){
          corr_list[[participant_vars[i]]] = apply(target_participants,2,function(x) phi(gr,x))
          } else {
          corr_list[[participant_vars[i]]] = apply(target_participants,2,function(x) cramer(gr,x))
          }
        }
      }
  corrs = corr_list %>% tibble::as_tibble()
  names(corrs) = paste0(names(corrs), "_corr")
  corrs = corrs %>% dplyr::mutate(target = colnames(target_participants))

  # join
  associations$targets = associations$targets %>%
    dplyr::left_join(corrs)

  # out
  associations
  }
