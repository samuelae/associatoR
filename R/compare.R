#' Compare responses
#'
#' \code{ar_compare} compares responses across participant variables by returning summary statistics.
#'
#' @param associations an \code{associatoR} object containing association data as generated by \link[associatoR]{ar_import} with targets defined by \link[associatoR]{ar_set_targets}.
#' @param participant_vars a \code{character} vector specifying the grouping variables.
#' @param target_var an optional \code{character} string specifying the target variable to be summarized. If not specified \code{ar_comapre} tabulates the frequencies of targets.
#' @param fun a \code{character} string of "count" to return counts or a function specifying the statistic to calculate from \code{target_var}, e.g. mean, sd, etc.
#' @param ... additional arguments passed on to fun
#'
#' @return Returns a \link[tibble]{tibble} containing grouped summaries (counts, or other custom statistics).
#'
#'
#' @examples
#' # calculate counts by using fun = "count"
#' ar_import(intelligence,
#'           participant = participant_id,
#'           cue = cue,
#'           response = response,
#'           participant_vars = c(gender, education),
#'           response_vars = c(response_position, response_level)) %>%
#'   ar_set_targets(targets = "cues") %>%
#'   ar_count_targets() %>%
#'   ar_compare(participant_vars = c(gender, education), target_var = frequency, fun = "count")
#'
#' # calculate means by using fun = mean and passing na.rm argument to mean()
#' ar_import(intelligence,
#'           participant = participant_id,
#'           cue = cue,
#'           response = response,
#'           participant_vars = c(gender, education),
#'           response_vars = c(response_position, response_level)) %>%
#'   ar_set_targets(targets = "cues") %>%
#'   ar_count_targets() %>%
#'   ar_compare(participant_vars = c(gender, education), target_var = frequency, fun = mean, na.rm = TRUE)
#'
#' # calculate standard deviations by using fun = sd
#' ar_import(intelligence,
#'           participant = participant_id,
#'           cue = cue,
#'           response = response,
#'           participant_vars = c(gender, education),
#'           response_vars = c(response_position, response_level)) %>%
#'   ar_set_targets(targets = "cues") %>%
#'   ar_count_targets() %>%
#'   ar_compare(participant_vars = c(gender, education), target_var = frequency, fun = sd, na.rm = TRUE)
#'
#' @export

ar_compare = function(associations,
                      participant_vars,
                      target_var,
                      fun = "count",
                      ...) {

  # checks
  check_object(associations)
  check_targets(associations)
  if(chk::vld_function(fun)) {
    chk::chk_function(fun)
  } else if (chk::vld_character(fun)) {
    chk::chk_subset(fun, c("count"))
  } else {
    stop(chk::message_chk("the argument `fun` must be either of type character and match \"count\", or be a function"))
  }

  # get vars and check
  p_vars = dplyr::enquo(participant_vars)
  t_var = dplyr::enquo(target_var)

  # get groups
  data = associations$responses %>%
    dplyr::left_join(associations$participants %>% dplyr::select(id, !!p_vars), by = "id") %>%
    dplyr::filter(response %in% associations$targets$target) %>%
    dplyr::left_join(associations$targets, by = c("response" = "target")) %>%
    dplyr::mutate(target = response)

  if(!is.function(fun)) {
    # fun is predefined
    if(fun[1] == "count") {
      # do counts
      out = data %>%
        dplyr::group_by(dplyr::across(c(!!p_vars, !!t_var))) %>%
        dplyr::summarize(n = length(!!t_var)) %>%
        dplyr::ungroup() %>%
        tidyr::pivot_wider(names_from = !!t_var,
                           values_from = n) %>%
        dplyr::mutate_all(tidyr::replace_na, 0)
    }
  } else {
    # do custom fun, potentially with ... arguments
    out = data %>%
      dplyr::group_by(dplyr::across(c(!!p_vars))) %>%
      dplyr::summarize(!!rlang::ensym(target_var) := fun(!!t_var, ...)) %>%
      dplyr::ungroup()
  }

  # out
  out

}


#' Embedding similarity comparison
#'
#' \code{ar_compare_embeddings} compares embeddings between groups using representational similarity analysis
#'
#' Representational similarity is calculated based on the Spearman correlation between cosine similarity matrices extracted from each embedding specified by one or more grouping factors.
#'
#' @param associations an \code{associatoR} object including target_embeddings.
#' @param participant_vars one or more column names specifying the grouping variables for embedding comparisons.
#' @param type a \code{character} specifying whether to compute representational similarity based on the full \code{"triangle"} or \code{"row"}-wise. Default is \code{"triangle"}.
#' @param intersection a \code{character} specifying whether to compute representations for the set of targets shared by all groups (\code{"all"}) or only by the individual pair (\code{"pair"}). The default is (\code{"pair"}).
#' @param ... arguments passed on to \code{ar_embed_targets}. If no arguments are specified arguments are taken from an existing \code{target_embedding} or based on default values.
#'
#' @return The function returns a table of representation similarities.
#'
#' @examples
#' ar_obj = ar_import(intelligence,
#'                    participant = participant_id,
#'                    cue = cue,
#'                    response = response,
#'                    participant_vars = c(gender, education),
#'                    response_vars = c(response_position, response_level)) %>%
#'   ar_set_targets(targets = "cues") %>%
#'   ar_embed_targets()
#'
#' ar_compare_embeddings(ar_obj, c(gender, education))
#'
#' @export
ar_compare_embeddings = function(associations, participant_vars, type = "triangle", intersection = "pair", ...) {

  # check inputs
  check_object(associations)
  check_targets(associations)
  chk::chk_subset(type, c("triangle","row"))
  chk::chk_subset(intersection, c("pair","all"))

  # get cases
  p_vars = dplyr::enquo(participant_vars)
  cases = associations$participants %>%
    dplyr::select(!!p_vars) %>%
    dplyr::distinct()

  # recreate data
  part_names = names(associations$participants)
  resp_names = names(associations$responses)
  cue_names = names(associations$cues)
  tbl = associations$participants %>%
    dplyr::left_join(associations$responses, by = "id") %>%
    dplyr::left_join(associations$cues, by = "cue")

  # embedding container
  embeddings = list()

  # embedding settings
  if("target_embedding" %in% names(associations)){
    embedding_settings = attr(associations$target_embedding, "embedding_settings")
  } else {
    embedding_settings = list(method = "ppmi-svd",
                              min_count = 5,
                              n_dim = 300,
                              model = NULL,
                              token = NULL,
                              context = NULL)
  }


  # embedding settings
  args = list(...)
  if(length(args) > 0){
    for(j in 1:length(args)){
      if(names(args)[j] %in% names(embedding_settings)){
        embedding_settings[[names(args)[j]]] = args[[j]]
      } else {
        stop("Arguments supplied for ... must match ar_embed_targets()")
      }
    }
  }

  # iterate
  for(i in 1:nrow(cases)){

    # get case selector
    filters = list()
    for(j in 1:ncol(cases)){
      filters[[j]] =  tbl[[names(cases)[j]]] == cases[[j]][i]
      }
    sel = do.call(cbind, filters) %>% rowMeans() %>% `==`(1)

    # select data
    tbl_sel = tbl %>% dplyr::slice(which(sel))

    # import
    data = ar_import(tbl_sel,
                     participant = id,
                     cue = cue,
                     response = response,
                     participant_vars = part_names[!part_names %in% "id"],
                     cue_vars = cue_names[!cue_names %in% "cue"],
                     response_vars = resp_names[!resp_names %in% c("id", "cue", "response")])

    # set targets
    data = do.call(ar_set_targets, c(list(data), attr(associations$targets, "target_settings")))

    # run embedding
    data = do.call(ar_embed_targets, c(list(data), embedding_settings)) %>%
      suppressWarnings()

    # store
    embeddings[[i]] = data$target_embedding
    }

  # get cosine
  coss = lapply(embeddings, function(emb){
    emb_mat = emb %>%
      dplyr::select(-target) %>%
      as.matrix()
    rownames(emb_mat) = emb$target
    emb_mat %>% cosine()
      })

  # get intersect
  dict = lapply(embeddings, function(emb) emb$target) %>% Reduce(f = intersect)


  # run repr sim
  sims = list()
  for(i in 1:(nrow(cases)-1)){
    for(j in (i+1):nrow(cases)){

      # get ids
      id_i = cases %>% dplyr::slice(i) %>% unlist() %>% paste0(collapse="-")
      id_j = cases %>% dplyr::slice(j) %>% unlist() %>% paste0(collapse="-")

      # intersect
      if(intersection == "all"){
        counts = c(nrow(coss[[i]]), nrow(coss[[j]]), length(dict))
        cos_i = coss[[i]][dict, dict]
        cos_j = coss[[j]][dict, dict]
      } else {
        pair_dict = intersect(rownames(coss[[i]]), rownames(coss[[j]]))
        counts = c(nrow(coss[[i]]), nrow(coss[[j]]), length(pair_dict))
        cos_i = coss[[i]][pair_dict, pair_dict]
        cos_j = coss[[j]][pair_dict, pair_dict]
      }

      # get sim
      if(type == "triangle"){
        sim = triangle_sim(cos_i, cos_j)
        } else {
        sim = row_sim(cos_i, cos_j)
        }

      sims[[length(sims) + 1]] = c(id_i, id_j, counts, sim)

    }
  }

  # out
  out = sims %>% do.call(what = rbind)
  colnames(out) = c("group_i", "group_j", "targets_i", "targets_j", "targets_shared", "similarity")
  out %>% tibble::as_tibble() %>%
    readr::type_convert() %>%
    suppressMessages()

}


