#' Compare responses
#'
#' \code{ar_compare} compares responses across participant variables by returning summary statistics.
#'
#' @param associations an \code{associatoR} object containing association data as generated by \link[associatoR]{ar_import} with targets defined by \link[associatoR]{ar_set_targets}.
#' @param participant_vars a \code{character} vector specifying the grouping variables.
#' @param target_var an optional \code{character} string specifying the target variable to be summarized. If not specified \code{ar_comapre} tabulates the frequencies of targets.
#' @param fun a \code{character} string of "count" to return counts or a function specifying the statistic to calculate from \code{target_var}, e.g. mean, sd, etc.
#' @param ... additional arguments passed on to fun
#'
#' @return Returns a \link[tibble]{tibble} containing grouped summaries (counts, or other custom statistics).
#'
#'
#' @examples
#' # calculate counts by using fun = "count"
#' ar_import(intelligence,
#'           participant = participant_id,
#'           cue = cue,
#'           response = response,
#'           participant_vars = c(gender, education),
#'           response_vars = c(response_position, response_level)) %>%
#'   ar_set_targets(targets = "cues") %>%
#'   ar_count_targets() %>%
#'   ar_compare(participant_vars = c(gender, education), target_var = frequency, fun = "count")
#'
#' # calculate means by using fun = mean and passing na.rm argument to mean()
#' ar_import(intelligence,
#'           participant = participant_id,
#'           cue = cue,
#'           response = response,
#'           participant_vars = c(gender, education),
#'           response_vars = c(response_position, response_level)) %>%
#'   ar_set_targets(targets = "cues") %>%
#'   ar_count_targets() %>%
#'   ar_compare(participant_vars = c(gender, education), target_var = frequency, fun = mean, na.rm = TRUE)
#'
#' # calculate standard deviations by using fun = sd
#' ar_import(intelligence,
#'           participant = participant_id,
#'           cue = cue,
#'           response = response,
#'           participant_vars = c(gender, education),
#'           response_vars = c(response_position, response_level)) %>%
#'   ar_set_targets(targets = "cues") %>%
#'   ar_count_targets() %>%
#'   ar_compare(participant_vars = c(gender, education), target_var = frequency, fun = sd, na.rm = TRUE)
#'
#' @export

ar_compare = function(associations,
                      participant_vars,
                      target_var,
                      fun = "count",
                      ...) {

  # checks
  chk::chk_s3_class(associations, "associatoR")
  chk::chk_subset("targets", names(associations))
  if(chk::vld_function(fun)) {
    chk::chk_function(fun)
  } else if (chk::vld_character(fun)) {
    chk::chk_subset(fun, c("count"))
  } else {
    stop(chk::message_chk("the argument `fun` must be either of type character and match \"count\", or be a function"))
  }

  # get vars and check
  p_vars = dplyr::enquo(participant_vars)
  t_var = dplyr::enquo(target_var)

  # get groups
  data = associations$responses %>%
    dplyr::left_join(associations$participants %>% dplyr::select(id, !!p_vars), by = "id") %>%
    dplyr::filter(response %in% associations$targets$target) %>%
    dplyr::left_join(associations$targets, by = c("response" = "target")) %>%
    dplyr::mutate(target = response)

  if(!is.function(fun)) {
    # fun is predefined
    if(fun[1] == "count") {
      # do counts
      out = data %>%
        dplyr::group_by(dplyr::across(c(!!p_vars, !!t_var))) %>%
        dplyr::summarize(n = length(!!t_var)) %>%
        dplyr::ungroup() %>%
        tidyr::pivot_wider(names_from = !!t_var,
                           values_from = n) %>%
        dplyr::mutate_all(tidyr::replace_na, 0)
    }
  } else {
    # do custom fun, potentially with ... arguments
    out = data %>%
      dplyr::group_by(dplyr::across(c(!!p_vars))) %>%
      dplyr::summarize(!!rlang::ensym(target_var) := fun(!!t_var, ...)) %>%
      dplyr::ungroup()
  }

  # out
  out

}
